<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Rand Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Extended documentation for Rust's Rand lib">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="intro.html">Introduction</a></li><li><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><a href="guide.html"><strong aria-hidden="true">2.</strong> Guide</a></li><li><ol class="section"><li><a href="guide-data.html"><strong aria-hidden="true">2.1.</strong> Random data</a></li><li><a href="guide-gen.html"><strong aria-hidden="true">2.2.</strong> Random generators</a></li><li><a href="guide-rngs.html"><strong aria-hidden="true">2.3.</strong> Our RNGs</a></li><li><a href="guide-values.html"><strong aria-hidden="true">2.4.</strong> Random values</a></li><li><a href="guide-dist.html"><strong aria-hidden="true">2.5.</strong> Random distributions</a></li><li><a href="guide-seq.html"><strong aria-hidden="true">2.6.</strong> Sequences</a></li><li><a href="guide-err.html"><strong aria-hidden="true">2.7.</strong> Error handling</a></li></ol></li><li><a href="portability.html"><strong aria-hidden="true">3.</strong> Portability</a></li><li><a href="update.html"><strong aria-hidden="true">4.</strong> Updating</a></li><li><ol class="section"><li><a href="update-0.5.html"><strong aria-hidden="true">4.1.</strong> Updating to 0.5</a></li><li><a href="update-0.6.html"><strong aria-hidden="true">4.2.</strong> Updating to 0.6</a></li></ol></li><li><a href="contributing.html"><strong aria-hidden="true">5.</strong> Contributing</a></li><li><ol class="section"><li><a href="contrib-doc.html"><strong aria-hidden="true">5.1.</strong> Documentation</a></li><li><a href="contrib-test.html"><strong aria-hidden="true">5.2.</strong> Testing</a></li><li><a href="contrib-bench.html"><strong aria-hidden="true">5.3.</strong> Benchmarks</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Rand Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#the-rust-rand-book" id="the-rust-rand-book"><h1>The Rust Rand Book</h1></a>
<p>This is the extended documentation set for Rust's <strong>Rand</strong>om number lib.</p>
<p>See also:</p>
<ul>
<li><a href="https://github.com/rust-random/rand">The Rand repository</a></li>
<li><a href="https://docs.rs/rand/">API reference for the latest release</a></li>
<li><a href="https://rust-random.github.io/rand/">API reference for the master branch</a></li>
</ul>
<p>Requirements and feature flags are not documented in this book; please see the
<a href="https://crates.io/crates/rand">crate page</a>.</p>
<a class="header" href="#a-hrefoverviewhtmloverviewa" id="a-hrefoverviewhtmloverviewa"><h2><a href="overview.html">Overview</a></h2></a>
<p>A quick introduction to the various crates, modules and traits.</p>
<a class="header" href="#a-hrefguidehtmlguidea" id="a-hrefguidehtmlguidea"><h2><a href="guide.html">Guide</a></h2></a>
<p>Want an overview of how everything fits together? Or confused by some of the
terminology used in this lib? Read the guide.</p>
<a class="header" href="#a-hrefportabilityhtmlportabilitya" id="a-hrefportabilityhtmlportabilitya"><h2><a href="portability.html">Portability</a></h2></a>
<p>&quot;Random number generation&quot; often involves producing deterministic yet &quot;random&quot;
data. If you wish to produce reproducible results (i.e. deterministic, stable
and portable), then you should read this chapter.</p>
<a class="header" href="#a-hrefcontributinghtmlcontributinga" id="a-hrefcontributinghtmlcontributinga"><h2><a href="contributing.html">Contributing</a></h2></a>
<p>About contributing to the Rand project and running its tests and benchmarks.</p>
<a class="header" href="#overview" id="overview"><h1>Overview</h1></a>
<p>This section provides a birds-eye view of Rand. If you want more details,
skip to the next section, <a href="guide.html">the guide</a>.</p>
<p>The following example demonstrates usage of the <a href="../rand/rand/prelude/index.html"><code>prelude</code></a>, <a href="../rand/rand/fn.random.html"><code>random()</code></a>,
<a href="../rand/rand/fn.thread_rng.html"><code>thread_rng()</code></a> and <a href="../rand/rand/trait.Rng.html#method.gen"><code>Rng::gen()</code></a>:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

// import commonly used items from the prelude:
use rand::prelude::*;

fn main() {
    // We can use random() immediately. It can produce values of many common types:
    let x: u8 = random();
    println!(&quot;{}&quot;, x);

    let y = random::&lt;f64&gt;();
    println!(&quot;{}&quot;, y);

    if random() { // generates a boolean
        println!(&quot;Heads!&quot;);
    }

    // If we want to be a bit more explicit (and a little more efficient) we can
    // make a handle to the thread-local generator:
    let mut rng = thread_rng();
    if rng.gen() { // random bool
        let x: f64 = rng.gen(); // random number in range [0, 1)
        println!(&quot;x is: {}&quot;, x);
        println!(&quot;Random char: {}&quot;, rng.gen::&lt;char&gt;());
        println!(&quot;Number from 0 to 9: {}&quot;, rng.gen_range(0, 10));
    }
}
</code></pre></pre>
<a class="header" href="#producers" id="producers"><h2>Producers</h2></a>
<p>Tying produces and consumers together, we have the <a href="../rand/rand/trait.RngCore.html"><code>RngCore</code></a> trait
(defined in <a href="https://crates.io/crates/rand_core"><code>rand_core</code></a> but also available from <a href="https://crates.io/crates/rand"><code>rand</code></a>).</p>
<p>All deterministic producers should implement <a href="../rand/rand/trait.SeedableRng.html"><code>SeedableRng</code></a>, which concerns
seeding of PRNGs.</p>
<p>Any implementor of <a href="../rand/rand/trait.SeedableRng.html"><code>SeedableRng</code></a> is automatically supported by <a href="../rand/rand/trait.FromEntropy.html"><code>FromEntropy</code></a>
which allows easy construction from an external source of randomness. For more
direct usage, <a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a> and <a href="../rand/rand/rngs/struct.OsRng.html"><code>OsRng</code></a> directly provide data from external
sources.</p>
<p>Two &quot;standard&quot; PRNG algorithms are provided: <a href="../rand/rand/rngs/struct.StdRng.html"><code>StdRng</code></a> and <a href="../rand/rand/rngs/struct.SmallRng.html"><code>SmallRng</code></a>.
Meanwhile many more are available from other crates, including several within
the scope of this project and several more outside of it.</p>
<p>The <a href="../rand/rand/fn.thread_rng.html"><code>thread_rng()</code></a> function provides a convenient, thread-local, auto-seeded,
crypto-grade random number generator.</p>
<a class="header" href="#consumers" id="consumers"><h2>Consumers</h2></a>
<p>The <a href="../rand/rand/trait.Rng.html"><code>Rng</code></a> trait provides a layer of convenience on top of <a href="../rand/rand/trait.RngCore.html"><code>RngCore</code></a>, whose
highlights are:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.gen"><code>Rng::gen()</code></a> provides a random value of any type supporting the <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> distribution.</li>
<li><a href="../rand/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range(low, high)</code></a> provides a uniform random value within the given range.</li>
<li><a href="../rand/rand/trait.Rng.html#method.gen_bool"><code>Rng::gen_bool(p)</code></a> yields <code>true</code> with probability <code>p</code>.</li>
<li><a href="../rand/rand/trait.Rng.html#method.sample"><code>Rng::sample(distribution)</code></a> produces a value from the supplied <code>distribution</code>.</li>
<li><a href="../rand/rand/trait.Rng.html#method.fill"><code>Rng::fill(dest)</code></a> fills any &quot;byte slice&quot; with random data.</li>
</ul>
<p>The <a href="../rand/rand/fn.random.html"><code>random()</code></a> function is a wrapper around <a href="../rand/rand/trait.Rng.html#method.gen"><code>Rng::gen()</code></a> on <a href="../rand/rand/fn.thread_rng.html"><code>thread_rng()</code></a>.</p>
<a class="header" href="#distributions" id="distributions"><h3>Distributions</h3></a>
<p>The <a href="../rand/rand/distributions/index.html"><code>distributions</code></a> module governs conversion of random data to meaningful typed
random values. Key contents:</p>
<ul>
<li><a href="../rand/rand/distributions/trait.Distribution.html"><code>Distribution&lt;T&gt;</code></a> is the trait governing production of values of type <code>T</code>
from a configured distribution; its key function is <a href="../rand/rand/distributions/trait.Distribution.html#tymethod.sample"><code>Distribution::sample</code></a>.</li>
<li><a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> is a zero-config distribution supporting sampling of values in
the &quot;expected&quot; manner for the given type (with explicit support for many
different types, from ints to floats to tuples, arrays and <code>Option</code>).</li>
<li><a href="../rand/rand/distributions/struct.Open01.html"><code>Open01</code></a> and <a href="../rand/rand/distributions/struct.OpenClosed01.html"><code>OpenClosed01</code></a> provide variations on sampling floating point
values from the 0-1 range.</li>
<li><a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> is the backbone behind <a href="../rand/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range(low, high)</code></a>, allowing uniform sampling
from a configured type-specific range.</li>
</ul>
<p>Many more distributions are available; consult the API documentation.</p>
<a class="header" href="#sequences" id="sequences"><h3>Sequences</h3></a>
<p>The <a href="../rand/rand/seq/index.html"><code>seq</code></a> module allows:</p>
<ul>
<li>sampling one (<code>choose</code>) or multiple (<code>choose_multiple</code>) elements from iterators and slices</li>
<li>weighted sampling (<code>choose_weighted</code> via the <code>WeightedIndex</code> distribution)</li>
<li>shuffling a slice</li>
</ul>
<a class="header" href="#guide" id="guide"><h1>Guide</h1></a>
<p>This section attempts to explain some of the concepts used in this library.</p>
<ol>
<li><a href="guide-data.html">What is random data and what is randomness anyway?</a></li>
<li><a href="guide-gen.html">What kind of random generators are there?</a></li>
<li><a href="guide-rngs.html">What random number generators does Rand provide?</a></li>
<li><a href="guide-values.html">Turning random data into useful values</a></li>
<li><a href="guide-dist.html">Distributions: more control over random values</a></li>
<li><a href="guide-seq.html">Sequences</a></li>
<li><a href="guide-err.html">Error handling</a></li>
</ol>
<a class="header" href="#importing-items-prelude" id="importing-items-prelude"><h2>Importing items (prelude)</h2></a>
<p>The most convenient way to import items from Rand is to use the <a href="../rand/rand/prelude/index.html"><code>prelude</code></a>.
This includes the most important parts of Rand, but only those unlikely to
cause name conflicts.</p>
<p>Note that Rand 0.5 has significantly changed the module organization and
contents relative to previous versions. Where possible old names have been
kept (but are hidden in the documentation), however these will be removed
in the future. We therefore recommend migrating to use the prelude or the
new module organization in your imports.</p>
<a class="header" href="#distinction-between-rand-and-rand_core" id="distinction-between-rand-and-rand_core"><h2>Distinction between Rand and <code>rand_core</code></h2></a>
<p>TODO: move this to a &quot;crate overview&quot;</p>
<p>The [<code>rand_core</code>] crate provides the necessary traits and functionality for
implementing RNGs; this includes the [<code>RngCore</code>] and [<code>SeedableRng</code>] traits
and the [<code>Error</code>] type.
Crates implementing RNGs should depend on [<code>rand_core</code>].</p>
<p>Applications and libraries consuming random values are encouraged to use the
Rand crate, which re-exports the common parts of [<code>rand_core</code>].</p>
<a class="header" href="#further-examples" id="further-examples"><h2>Further examples</h2></a>
<p>For some inspiration, see the example applications:</p>
<ul>
<li><a href="https://github.com/rust-random/rand/blob/master/examples/monte-carlo.rs">Monte Carlo estimation of π</a></li>
<li><a href="https://github.com/rust-random/rand/blob/master/examples/monty-hall.rs">Monty Hall Problem</a></li>
</ul>
<a class="header" href="#random-data" id="random-data"><h1>Random data</h1></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate rand;
# use rand::RngCore;
// get some random data:
let mut data = [0u8; 32];
rand::thread_rng().fill_bytes(&amp;mut data);
#}</code></pre></pre>
<a class="header" href="#what-is-randomness" id="what-is-randomness"><h2>What is randomness?</h2></a>
<p>What does <strong>random</strong> mean? Colloquially the word can mean simply <em>unexpected</em>
or <em>unknown</em>, but we need to be a bit more precise than that. Wikipedia gives us
a more specific definition:</p>
<blockquote>
<p><strong>Randomness</strong> is the lack of pattern or predictability in events.</p>
</blockquote>
<p>We can take this further: <em>lack of pattern</em> implies there is no <em>bias</em>; in
other words, all possible values are equally likely.</p>
<p>To understand what a <em>random value</em> is, we still need a context: what pool of
numbers can our random value come from?</p>
<ul>
<li>To give a simple example, consider dice: they have values 1, 2, 3, 4, 5 and
6, and an unbiased (fair) die will make each number equally likely.</li>
<li>Now lets take a silly example: the natural numbers (1, 2, 3, etc.). These
numbers have no limit. So if you were to ask for an unbiased random
natural number, 1, 5, 1000, 1 million, 1 trillion — all would be equally
likely. Since there is no upper bound here, the <em>expected value</em> (the
&quot;average&quot; value) is infinitely large. So maybe this isn't useful to us.</li>
<li>Another example: real numbers between 0 and 1. Real numbers include all the
fractions, irrational numbers like π and √2, and all multiples of those...
there are infinitely many possibilities, even in a small range like <code>(0, 1)</code>,
so simply saying &quot;all possibilities are equally likely&quot; is not enough.
Instead we interpret <em>lack of pattern</em> in a different way: every interval
of equal size is equally likely; e.g. 0-0.1 is just as likely as 0.1-0.2
and 0.9-1.0 to contain our random value.</li>
</ul>
<p>To bring us back to computing, we can now define what an <em>unbiased random value</em>
is in several contexts:</p>
<ul>
<li><code>u32</code>: a random number between 0 and <code>u32::MAX</code> where each value is equally
likely</li>
<li><code>BigInt</code>: since this type has no upper bound, we cannot produce an unbiased
random value (it would be infinitely large, and use infinite amounts of memory)</li>
<li><code>f64</code>: again, this has a large range, however, <em>by convention</em>, we usually
restrict to the range 0 to 1 (if not otherwise specified)</li>
</ul>
<a class="header" href="#random-data-1" id="random-data-1"><h2>Random data</h2></a>
<p>As seen above, the term &quot;random number&quot; is meaningless without context. &quot;Random
data&quot; typically means a sequence of random <em>bytes</em>, where for each byte, each of
the 256 possible values are equally likely.</p>
<p><a href="../rand/rand_core/trait.RngCore.html#tymethod.fill_bytes"><code>RngCore::fill_bytes</code></a> produces exactly this: a sequence of random bytes.</p>
<p>If a sequence of unbiased random bytes of the correct length is instead
interpreted as an integer — say a <code>u32</code> or <code>u64</code> — the result is an unbiased
integer. Since this conversion is trivial, <a href="../rand/rand_core/trait.RngCore.html#tymethod.next_u32"><code>RngCore::next_u32</code></a> and
<a href="../rand/rand_core/trait.RngCore.html#tymethod.next_u64"><code>RngCore::next_u64</code></a> are part of the same trait. (In fact the conversion is
often the other way around — algorithmic generators usually work with integers
internally, which are then converted to whichever form of random data is
required.)</p>
<a class="header" href="#random-generators" id="random-generators"><h1>Random generators</h1></a>
<p>The previous section introduced <a href="../rand/rand_core/trait.RngCore.html"><code>RngCore</code></a>, the trait which all <em>random data
sources</em> must implement. But what exactly is a random data source?</p>
<p>This section concerns theory; see also the chapter on
<a href="rngs.html">random number generators</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate rand;
// prepare a random number generator:
let mut rng = rand::thread_rng();
#}</code></pre></pre>
<a class="header" href="#true-random-number-generators" id="true-random-number-generators"><h2>True random number generators</h2></a>
<p>A <strong>true</strong> random number generator (TRNG) is something which produces random
numbers by observing some natural process, such as atomic decay or thermal noise.
(Whether or not these things are <em>truely</em> random or are in fact deterministic —
for example if the universe itself is a simulation — is besides the point here.
Since from our point of view these things are unpredictable and we require some
source of <em>entropy</em>, we are forced to assume that at least some such processes
are truely random.)</p>
<p>Note that these processes are often biased, thus some type of <em>debiasing</em> must
be used to yield the unbiased random data we desire.</p>
<a class="header" href="#psuedo-random-number-generators" id="psuedo-random-number-generators"><h2>Psuedo-random number generators</h2></a>
<p>CPUs are of course supposed to compute deterministically, yet it turns out they
can do a pretty good job of emulating random processes. Most psuedo-random
number generators are deterministic and can be defined by three things:</p>
<ul>
<li>some initial <em>state</em></li>
<li>a function to compute a random value from the state</li>
<li>a function to advance to the next state</li>
</ul>
<p>The fact that these are deterministic can sometimes be very useful: it allows a
simulation, randomised art work or game to be repeated exactly, producing a
result which is a function of the seed. For more on this see the
<a href="portability.html">portability</a> chapter (note that deterministicity alone isn't
enough to guarantee reproducibility).</p>
<p>The other big attraction of PRNGs is their speed: some of these algorithms
require only a few CPU operations per random value, and thus can produce
random data on demand much more quickly than most TRNGs.</p>
<p>Note however that PRNGs have several limitations:</p>
<ul>
<li>They are no stronger than their seed: if the seed is known or guessable,
and the algorithm is known (or guessed), then only a small number of output
sequences are likely.</li>
<li>Since the state size is usually fixed, only a finite number of output values
are possible before the generator loops and repeats itself.</li>
<li>Several algorithms are easily predictable after seeing a few values, and
with many other algorithms it is not clear whether they could be &quot;cracked&quot;.</li>
</ul>
<p>TODO: move
This is usually
not an issue in practice; for example 16 bytes allows a length of 2^128
values (approx 10^38); since modern CPUs have &quot;only&quot; around 10^17 clock
cycles per year even a super fast generator producing one value per cycle
would take 10^21 years to run its cycle.</p>
<a class="header" href="#crytographically-secure-pseudo-random-number-generator" id="crytographically-secure-pseudo-random-number-generator"><h2>Crytographically secure pseudo-random number generator</h2></a>
<p>Crytographically secure pseudo-random number generators (CSPRNGs) are the
subset of PRNGs which are considered secure. That is:</p>
<ul>
<li>their state is sufficiently large that a brute-force approach simply trying
all initial values is not a feasible method of finding the initial state
used to produce an observed sequence of output values,</li>
<li>and there is no other algorithm which is sufficiently better than the
brute-force method which would make it feasible to predict the next output
value.</li>
</ul>
<p>Achieving secure generation requires not only a secure algorithm (CSPRNG), but
also a secure and sufficiently large seed value (typically 256 bits), and
protection against side-channel attacks (i.e. preventing attackers from reading
the internal state).</p>
<p>Some CSPRNGs additionally satisfy a third property:</p>
<ul>
<li>a CSPRNG is backtracking resistant if it is impossible for an attacker to
calculate prior output values of the PRNG despite having discovered the
value of the current internal state (implying that all future output is
compromised).</li>
</ul>
<a class="header" href="#hardware-random-number-generator" id="hardware-random-number-generator"><h2>Hardware random number generator</h2></a>
<p>A <strong>hardware</strong> random number generator (HRNG) may be a TRNG or a PRNG or some
combination of the two.</p>
<a class="header" href="#entropy" id="entropy"><h2>Entropy</h2></a>
<p>As noted above, for a CSPRNG to be secure, its seed value must also be secure.
The word <em>entropy</em> can be used in two ways:</p>
<ul>
<li>as a measure of the amount of unknown information in some piece of data
(typically measured in bits; see Shannon Entropy)</li>
<li>as a piece of unknown data</li>
</ul>
<a class="header" href="#our-rngs" id="our-rngs"><h1>Our RNGs</h1></a>
<p>There are many kinds of RNGs, with different trade-offs. You can read more
about them in the [<code>rngs</code> module] and even more in the [<code>prng</code> module],
however, often you can just use [<code>thread_rng</code>]. This function
automatically initializes an RNG in thread-local memory, then returns a
reference to it. It is fast, good quality, and secure (unpredictable).</p>
<p>TODO</p>
<a class="header" href="#random-values" id="random-values"><h1>Random values</h1></a>
<p>Now that we have a way of producing random data, how can we convert it to the
type of value we want?</p>
<p>This is a trick question: we need to know both the <em>range</em> we want and the type
of <em>distribution</em> of this value (which is what the <a href="guide-dist.html"><code>next</code></a> section
is all about).</p>
<p>For convenience, all generators automatically implement the <a href="../rand/rand/trait.Rng.html"><code>Rng</code></a> trait,
which provides short-cuts to a few ways of generating values.
Some of the most useful methods are:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.gen"><code>gen</code></a> generates an unbiased random value from a range appropriate for the
type. For integers this is normally the full representable range
(e.g. from <code>0u32</code> to <code>std::u32::MAX</code>), for floats this is between 0 and 1,
and some other types are supported, including arrays and tuples.
More on this in the <a href="guide-dist.html#uniform-distributions">next section</a>.</li>
<li><a href="../rand/rand/trait.Rng.html#method.gen_range"><code>gen_range</code></a> generates an unbiased random value with given bounds
<code>low</code> (inclusive) and <code>high</code> (exclusive)</li>
<li><a href="../rand/rand/trait.Rng.html#method.sample"><code>sample</code></a> samples directly from some distribution</li>
<li><a href="../rand/rand/trait.Rng.html#method.gen_bool"><code>gen_bool</code></a> generates a boolean with the given probability</li>
<li><a href="../rand/rand/trait.Rng.html#method.gen_ratio"><code>gen_ratio</code></a> also generates a boolean, where the probability is defined
via a fraction</li>
<li><a href="../rand/rand/trait.Rng.html#method.fill"><code>fill</code></a> and <a href="../rand/rand/trait.Rng.html#method.try_fill"><code>try_fill</code></a> are optimised functions for filling any byte or
integer slice with random values</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate rand;
use rand::Rng;
let mut rng = rand::thread_rng();

// an unbiased integer over the entire range:
let i: i32 = rng.gen();

// a uniformly distributed value between 0 and 1:
let x: f64 = rng.gen();

// simulate rolling a die:
let roll = rng.gen_range(1, 7);
#}</code></pre></pre>
<p>Additionally, the <a href="../rand/rand/fn.random.htm"><code>random</code></a> function is a short-cut to <a href="../rand/rand/trait.Rng.html#method.gen"><code>gen</code></a> on the <a href="../rand/rand/fn.thread_rng.html"><code>thread_rng</code></a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if rand::random() {
    println!(&quot;we got lucky!&quot;);
}
#}</code></pre></pre>
<a class="header" href="#random-distributions" id="random-distributions"><h1>Random distributions</h1></a>
<p>For maximum flexibility when producing random values, we define the
<a href="../rand/rand/distributions/trait.Distribution.html"><code>Distribution</code></a> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// a producer of data of type T:
pub trait Distribution&lt;T&gt; {
    // the key function:
    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; T;

    // a convenience function defined using sample:
    fn sample_iter&lt;'a, R&gt;(&amp;'a self, rng: &amp;'a mut R) -&gt; DistIter&lt;'a, Self, R, T&gt;
    where
        Self: Sized,
        R: Rng,
    { ... }
}
#}</code></pre></pre>
<p>Rand provides implementations of many different distributions; for the full
list see the <a href="../rand/rand/distributions/index.html"><code>distributions</code></a> module; the most common are highlighted below.</p>
<a class="header" href="#uniform-distributions" id="uniform-distributions"><h2>Uniform distributions</h2></a>
<p>The most obvious type of distribution is the one we already discussed: one
without pattern, where each value or range of values is equally likely. This is
known as <em>uniform</em>.</p>
<p>Rand actually has several variants of this:</p>
<ul>
<li><a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> requires no parameters and produces uniformly distributed
values over the entire range of the output type (for <code>bool</code> and integers)
or over the range from 0 to 1 (for floats) or over valid unicode code
points. It also has extensions to tuples, array types and <code>Option</code>.</li>
<li><a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a> is parameterised with <code>low</code> and <code>high</code> points, and produces
values uniformly distributed within this range.</li>
<li><a href="../rand/rand/distributions/struct.Alphanumeric.html"><code>Alphanumeric</code></a> is uniform over the values <code>0-9A-Za-z</code></li>
<li><a href="../rand/rand/distributions/struct.Open01.html"><code>Open01</code></a> and <a href="../rand/rand/distributions/struct.OpenClosed01.html"><code>OpenClosed01</code></a> are variations of <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a> for floating
point numbers between 0 and 1 (partially) exclusive of end points.</li>
</ul>
<p>For convenience, <a href="../rand/rand/trait.Rng.html#method.gen"><code>Rng::gen</code></a> and <a href="../rand/rand/fn.random.htm"><code>random</code></a> are short-cuts to <a href="../rand/rand/distributions/struct.Standard.html"><code>Standard</code></a>,
and <a href="../rand/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range</code></a> is a short-cut to <a href="../rand/rand/distributions/struct.Uniform.html"><code>Uniform</code></a>, allowing things like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# extern crate rand;
# use rand::prelude::*;
let mut rng = thread_rng();
let cood: (f64, f64) = rng.gen();
let die_roll = rng.gen_range(1, 7);
#}</code></pre></pre>
<a class="header" href="#more-continuous-distributions" id="more-continuous-distributions"><h2>More continuous distributions</h2></a>
<p>The exponential distribution, <a href="../rand/rand/distributions/struct.Exp.html"><code>Exp</code></a>, simulates time until decay, assuming a
fixed rate of decay (i.e. exponential decay).</p>
<p>The <a href="../rand/rand/distributions/struct.Normal.html"><code>Normal</code></a> distribution (also known as Gaussian) simulates sampling from
the Normal distribution (&quot;Bell curve&quot;) with the given mean and standard
deviation. The <a href="../rand/rand/distributions/struct.LogNormal.html"><code>LogNormal</code></a> is related: for sample <code>X</code> from the log-normal
distribution, <code>log(X)</code> is normally distributed; this &quot;skews&quot; the normal
distribution to avoid negative values and to have a long positive tail.</p>
<p>The <a href="../rand/rand/distributions/struct.UnitCircle.html"><code>UnitCircle</code></a> and <a href="../rand/rand/distributions/struct.UnitSphereSurface.html"><code>UnitSphereSurface</code></a> distributions simulate uniform
sampling from the edge of a circle or surface of a sphere.</p>
<p>The <a href="../rand/rand/distributions/struct.Cauchy.html"><code>Cauchy</code></a> distribution (also known as the Lorentz distribution) is the
distribution of the x-intercept of a ray from point <code>(x0, γ)</code> with uniformly
distributed angle.</p>
<a class="header" href="#probability-distributions" id="probability-distributions"><h2>Probability distributions</h2></a>
<p>The <a href="../rand/rand/distributions/struct.Bernoulli.html"><code>Bernoulli</code></a> distribution is very simple: given a probability <code>p</code> (or a
ratio <code>num / denom</code>), a boolean value is produced with the given probability
of being <code>true</code> (simulating a trial with probability <code>p</code> of success).</p>
<p>For convenience, <a href="../rand/rand/trait.Rng.html#method.gen_bool"><code>Rng::gen_bool</code></a> and <a href="../rand/rand/trait.Rng.html#method.gen_ratio"><code>Rng::gen_ratio</code></a> are short-cuts to <a href="../rand/rand/distributions/struct.Bernoulli.html"><code>Bernoulli</code></a>.</p>
<p>The <a href="../rand/rand/distributions/struct.Binomial.html"><code>Binomial</code></a> distribution is related: given a probability <code>p</code> and a number
<code>n</code>, this distribution simulates running <code>n</code> Bernoulli trials and tells you the
number which were successful.</p>
<p>The <a href="../rand/rand/distributions/struct.Poisson.html"><code>Poisson</code></a> distribution expresses the expected number of events occurring
within a fixed interval, given that events occur with fixed rate λ.</p>
<p>The <a href="../rand/rand/distributions/struct.Beta.html"><code>Beta</code></a> distribution is a two-parameter probabilty distribution, whose
output values lie between 0 and 1. The <a href="../rand/rand/distributions/struct.Dirichlet.html"><code>Dirichlet</code></a> distribution is a
generalisation to any positive number of parameters.</p>
<a class="header" href="#weighted-sampling" id="weighted-sampling"><h2>Weighted sampling</h2></a>
<p>Finally, <a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a> is a discrete distribution sampling from a finite
selection of choices each with given weight.</p>
<a class="header" href="#sequences-1" id="sequences-1"><h1>Sequences</h1></a>
<p>Rand implements a few common random operations on sequences via the
<a href="../rand/rand/seq/trait.IteratorRandom.html"><code>IteratorRandom</code></a> and <a href="../rand/rand/seq/trait.SliceRandom.html"><code>SliceRandom</code></a> traits:</p>
<ul>
<li><code>choose</code> one element uniformly from the sequence</li>
<li><code>choose_multiple</code> elements uniformly without replacement</li>
<li><code>choose_weighted</code> — choose an element non-uniformly by use of a defined
weight from a slice (also see the <a href="../rand/rand/distributions/struct.WeightedIndex.html"><code>WeightedIndex</code></a> distribution)</li>
<li><code>shuffle</code> a slice</li>
<li><code>partial_shuffle</code> a slice, effectively extracting <code>amount</code> elements in
random order</li>
</ul>
<a class="header" href="#error-handling" id="error-handling"><h1>Error handling</h1></a>
<p>Error handling in Rand is a compromise between simplicity and necessity.
Most RNGs and sampling functions will never produce errors, and making these
able to handle errors would add significant overhead (to code complexity
and ergonomics of usage at least, and potentially also performance,
depending on the approach).
However, external RNGs can fail, and being able to handle this is important.</p>
<p>It has therefore been decided that <em>most</em> methods should not return a
<code>Result</code> type, but with a few important exceptions, namely:</p>
<ul>
<li><a href="../rand/rand/trait.Rng.html#method.try_fill"><code>Rng::try_fill</code></a></li>
<li><a href="../rand/rand_core/trait.RngCore.html#tymethod.try_fill_bytes"><code>RngCore::try_fill_bytes</code></a></li>
<li><a href="../rand/rand_core/trait.SeedableRng.html#method.from_rng"><code>SeedableRng::from_rng</code></a></li>
</ul>
<p>Most functions consuming random values will not attempt any error handling, and
reduce to calls to <a href="../rand/rand_core/trait.RngCore.html"><code>RngCore</code></a>'s &quot;infallible&quot; methods. Since most RNGs cannot
fail anyway this is usually not a problem, but the few generators which can may
be forced to fail in this case:</p>
<ul>
<li><a href="../rand/rand/rngs/struct.OsRng.html"><code>OsRng</code></a> interfaces with the Operating System's generator; in rare cases
this may fail as &quot;not ready&quot; or simply &quot;unavailable&quot;.</li>
<li><a href="../rand/rand/rngs/struct.JitterRng.html"><code>JitterRng</code></a> is a generator based on timer jitter; if the timer does not
appear to be capable of sufficient precision or is too predictable, this
will fail.</li>
<li><a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a> is an abstraction over the above, falling back to the next
option when the first fails but ultimately failing if all sources fail</li>
<li><a href="../rand/rand/fn.thread_rng.html"><code>thread_rng</code></a> seeds itself via <a href="../rand/rand/rngs/struct.EntropyRng.html"><code>EntropyRng</code></a>, thus can potentially fail
on its first use on each thread (though it never fails after the first use)</li>
<li><a href="../rand/rand/rngs/adapter/struct.ReadRng.html"><code>ReadRng</code></a> tries to read data from its source but fails when the stream
ends or errors (though it retries on interrupt).</li>
</ul>
<a class="header" href="#portability" id="portability"><h1>Portability</h1></a>
<a class="header" href="#updating" id="updating"><h1>Updating</h1></a>
<p>This guide is intended to facilitate upgrading to the next minor or major
version of Rand. Note that updating to the next patch version (e.g. 0.5.1 to
0.5.2) should never require code changes.</p>
<p>This guide gives a few more details than the <a href="https://github.com/rust-random/rand/blob/master/CHANGELOG.md">changelog</a>, in particular giving
guidance on how to use new features and migrate away from old ones.</p>
<a class="header" href="#updating-to-05" id="updating-to-05"><h1>Updating to 0.5</h1></a>
<p>The 0.5 release has quite significant changes over the 0.4 release; as such,
it may be worth reading through the following coverage of breaking changes.
This release also contains many optimisations, which are not detailed below.</p>
<a class="header" href="#crates" id="crates"><h2>Crates</h2></a>
<p>We have a new crate: <code>rand_core</code>! This crate houses some important traits,
<code>RngCore</code>, <code>BlockRngCore</code>, <code>SeedableRng</code> and <code>CryptoRng</code>, the error types, as
well as two modules with helpers for implementations: <code>le</code> and <code>impls</code>. It is
recommended that implementations of generators use the <code>rand_core</code> crate while
other users use only the <code>rand</code> crate, which re-exports most parts of <code>rand_core</code>.</p>
<p>The <code>rand_derive</code> crate has been deprecated due to very low usage and
deprecation of <code>Rand</code>.</p>
<a class="header" href="#features" id="features"><h2>Features</h2></a>
<p>Several new Cargo feature flags have been added:</p>
<ul>
<li><code>alloc</code>, used without <code>std</code>, allows use of <code>Box</code> and <code>Vec</code></li>
<li><code>serde1</code> adds serialization support to some PRNGs</li>
<li><code>log</code> adds logging in a few places (primarily to <code>OsRng</code> and <code>JitterRng</code>)</li>
</ul>
<a class="header" href="#rng-and-friends-core-traits" id="rng-and-friends-core-traits"><h2><code>Rng</code> and friends (core traits)</h2></a>
<p><code>Rng</code> trait has been split into two traits, a &quot;back end&quot; <code>RngCore</code> (implemented
by generators) and a &quot;front end&quot; <code>Rng</code> implementing all the convenient extension
methods.</p>
<p>Implementations of generators must <code>impl RngCore</code> instead. Usage of <code>rand_core</code>
for implementations is encouraged; the <code>rand_core::{le, impls}</code> modules may
prove useful.</p>
<p>Users of <code>Rng</code> <em>who don't need to implement it</em> won't need to make so many
changes; often users can forget about <code>RngCore</code> and only import <code>Rng</code>. Instead
of <code>RngCore::next_u32()</code> / <code>next_u64()</code> users should prefer <code>Rng::gen()</code>, and
instead of <code>RngCore::fill_bytes(dest)</code>, <code>Rng::fill(dest)</code> can be used.</p>
<a class="header" href="#rng--rngcore-methods" id="rng--rngcore-methods"><h3><code>Rng</code> / <code>RngCore</code> methods</h3></a>
<p>To allow error handling from fallible sources (e.g. <code>OsRng</code>), a new
<code>RngCore::try_fill_bytes</code> method has been added; for example <code>EntropyRng</code> uses
this mechanism to fall back to <code>JitterRng</code> if <code>OsRng</code> fails, and various
handlers produce better error messages.
As before, the other methods will panic on failure, but since these are usually
used with algorithmic generators which are usually infallible, this is
considered an appropriate compromise.</p>
<p>A few methods from the old <code>Rng</code> have been removed or deprecated:</p>
<ul>
<li><code>next_f32</code> and <code>next_f64</code>; these are no longer implementable by generators;
use <code>gen</code> instead</li>
<li><code>gen_iter</code>; users may instead use standard iterators with closures:
<code>::std::iter::repeat(()).map(|()| rng.gen())</code></li>
<li><code>gen_ascii_chars</code>; use <code>repeat</code> as above and <code>rng.sample(Alphanumeric)</code></li>
<li><code>gen_weighted_bool(n)</code>; use <code>gen_bool(1.0 / n)</code> instead</li>
</ul>
<p><code>Rng</code> has a few new methods:</p>
<ul>
<li><code>sample(distr)</code> is a shortcut for <code>distr.sample(rng)</code> for any <code>Distribution</code></li>
<li><code>gen_bool(p)</code> generates a boolean with probability <code>p</code> of being true</li>
<li><code>fill</code> and <code>try_fill</code>, corresponding to <code>fill_bytes</code> and <code>try_fill_bytes</code>
respectively (i.e. the only difference is error handling); these can fill
and integer slice / array directly, and provide better performance
than <code>gen()</code></li>
</ul>
<a class="header" href="#constructing-prngs" id="constructing-prngs"><h3>Constructing PRNGs</h3></a>
<a class="header" href="#new-randomly-initialised-prngs" id="new-randomly-initialised-prngs"><h4>New randomly-initialised PRNGs</h4></a>
<p>A new trait has been added: <code>FromEntropy</code>. This is automatically implemented for
any type supporting <code>SeedableRng</code>, and provides construction from fresh, strong
entropy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rand::{ChaChaRng, FromEntropy};

let mut rng = ChaChaRng::from_entropy();
#}</code></pre></pre>
<a class="header" href="#seeding-prngs" id="seeding-prngs"><h4>Seeding PRNGs</h4></a>
<p>The <code>SeedableRng</code> trait has been modified to include the seed type via an
associated type (<code>SeedableRng::Seed</code>) instead of a template parameter
(<code>SeedableRng&lt;Seed&gt;</code>). Additionally, all PRNGs now seed from a byte-array
(<code>[u8; N]</code> for some fixed N). This allows generic handling of PRNG seeding
which was not previously possible.</p>
<p>PRNGs are no longer constructed from other PRNGs via <code>Rand</code> support / <code>gen()</code>,
but through <code>SeedableRng::from_rng</code>, which allows error handling and is
intentionally explicit.</p>
<p><code>SeedableRng::reseed</code> has been removed since it has no utility over <code>from_seed</code>
and its performance advantage is questionable.</p>
<p>Implementations of <code>SeedableRng</code> may need to change their <code>Seed</code> type to a
byte-array; this restriction has been made to ensure portable handling of
Endianness. Helper functions are available in <code>rand_core::le</code> to read <code>u32</code> and
<code>u64</code> values from byte arrays.</p>
<a class="header" href="#block-based-prngs" id="block-based-prngs"><h3>Block-based PRNGs</h3></a>
<p>rand_core has a new helper trait, <code>BlockRngCore</code>, and implementation,
<code>BlockRng</code>. These are for use by generators which generate a block of random
data at a time instead of word-sized values. Using this trait and implementation
has two advantages: optimised <code>RngCore</code> methods are provided, and the PRNG can
be used with <code>ReseedingRng</code> with very low overhead.</p>
<a class="header" href="#cryptographic-rngs" id="cryptographic-rngs"><h3>Cryptographic RNGs</h3></a>
<p>A new trait has been added: <code>CryptoRng</code>. This is purely a marker trait to
indicate which generators should be suitable for cryptography, e.g.
<code>fn foo&lt;R: Rng + CryptoRng&gt;(rng: &amp;mut R)</code>. <em>Suitability for cryptographic
use cannot be guaranteed.</em></p>
<a class="header" href="#error-handling-1" id="error-handling-1"><h2>Error handling</h2></a>
<p>A new <code>Error</code> type has been added, designed explicitly for no-std compatibility,
simplicity, and enough flexibility for our uses (carrying a <code>cause</code> when
possible):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Error {
    pub kind: ErrorKind,
    pub msg: &amp;'static str,
    // some fields omitted
}
#}</code></pre></pre>
<p>The associated <code>ErrorKind</code> allows broad classification of errors into permanent,
unexpected, transient and not-yet-ready kinds.</p>
<p>The following use the new error type:</p>
<ul>
<li><code>RngCore::try_fill_bytes</code></li>
<li><code>Rng::try_fill</code></li>
<li><code>OsRng::new</code></li>
<li><code>JitterRng::new</code></li>
</ul>
<a class="header" href="#external-generators" id="external-generators"><h2>External generators</h2></a>
<p>We have a new generator, <code>EntropyRng</code>, which wraps <code>OsRng</code> and <code>JitterRng</code>
(preferring to use the former, but falling back to the latter if necessary).
This allows easy construction with fallback via <code>SeedableRng::from_rng</code>,
e.g. <code>IsaacRng::from_rng(EntropyRng::new())?</code>. This is equivalent to using
<code>FromEntropy</code> except for error handling.</p>
<p>It is recommended to use <code>EntropyRng</code> over <code>OsRng</code> to avoid errors on platforms
with broken system generator, but it should be noted that the <code>JitterRng</code>
fallback is very slow.</p>
<a class="header" href="#prngs" id="prngs"><h2>PRNGs</h2></a>
<p><em>Pseudo-Random Number Generators</em> (i.e. deterministic algorithmic generators)
have had a few changes since 0.4, and are now housed in the <code>prng</code> module
(old names remain temporarily available for compatibility; eventually these
generators will likely be housed outside the <code>rand</code> crate).</p>
<p>All PRNGs now do not implement <code>Copy</code> to prevent accidental copying of the
generator's state (and thus repetitions of generated values). Explicit cloning
via <code>Clone</code> is still available. All PRNGs now have a custom implementation of
<code>Debug</code> which does not print any internal state; this helps avoid accidentally
leaking cryptographic generator state in log files. External PRNG
implementations are advised to follow this pattern (see also doc on <code>RngCore</code>).</p>
<p><code>SmallRng</code> has been added as a wrapper, currently around <code>XorShiftRng</code> (but
likely another algorithm soon). This is for uses where small state and fast
initialisation are important but cryptographic strength is not required.
(Actual performance of generation varies by benchmark; dependending on usage
this may or may not be the fastest algorithm, but will always be fast.)</p>
<a class="header" href="#reseedingrng" id="reseedingrng"><h3><code>ReseedingRng</code></h3></a>
<p>The <code>ReseedingRng</code> wrapper has been signficantly altered to reduce overhead.
Unfortunately the new <code>ReseedingRng</code> is not compatible with all RNGs, but only
those using <code>BlockRngCore</code>.</p>
<a class="header" href="#isaac-prngs" id="isaac-prngs"><h3>ISAAC PRNGs</h3></a>
<p>The <code>IsaacRng</code> and <code>Isaac64Rng</code> PRNGs now have an additional construction
method: <code>new_from_u64(seed)</code>. 64 bits of state is insufficient for cryptography
but may be of use in simulations and games. This will likely be superceeded by
a method to construct any PRNG from any hashable object in the future.</p>
<a class="header" href="#hc-128" id="hc-128"><h3>HC-128</h3></a>
<p>This is a new cryptographic generator, selected as one of the &quot;stream ciphers
suitable for widespread adoption&quot; by eSTREAM. This is now the default
cryptographic generator, used by <code>StdRng</code> and <code>thread_rng()</code>.</p>
<a class="header" href="#helper-functionstraits" id="helper-functionstraits"><h2>Helper functions/traits</h2></a>
<p>The <code>Rand</code> trait has been deprecated. Instead, users are encouraged to use
<code>Standard</code> which is a real distribution and supports the same sampling as
<code>Rand</code>. <code>Rng::gen()</code> now uses <code>Standard</code> and should work exactly as before.
See the documentation of the <code>distributions</code> module on how to implement
<code>Distribution&lt;T&gt;</code> for <code>Standard</code> for user types <code>T</code></p>
<p><code>weak_rng()</code> has been deprecated; use <code>SmallRng::from_entropy()</code> instead.</p>
<a class="header" href="#distributions-1" id="distributions-1"><h2>Distributions</h2></a>
<p>The <code>Sample</code> and <code>IndependentSample</code> traits have been replaced by a single
trait, <code>Distribution</code>. This is largely equivalent to <code>IndependentSample</code>, but
with <code>ind_sample</code> replaced by just <code>sample</code>. Support for mutable distributions
has been dropped; although it appears there may be a few genuine uses, these
are not used widely enough to justify the existance of two independent traits
or of having to provide mutable access to a distribution object. Both <code>Sample</code>
and <code>IndependentSample</code> are still available, but deprecated; they will be
removed in a future release.</p>
<p><code>Distribution::sample</code> (as well as several other functions) can now be called
directly on type-erased (unsized) RNGs.</p>
<p><code>RandSample</code> has been removed (see <code>Rand</code> deprecation and new <code>Standard</code>
distribution).</p>
<p>The <code>Closed01</code> wrapper has been removed, but <code>OpenClosed01</code> has been added.</p>
<a class="header" href="#uniform-distributions-1" id="uniform-distributions-1"><h3>Uniform distributions</h3></a>
<p>Two new distributions are available:</p>
<ul>
<li><code>Standard</code> produces uniformly-distributed samples for many different types,
and acts as a replacement for <code>Rand</code></li>
<li><code>Alphanumeric</code> samples <code>char</code>s from the ranges <code>a-z A-Z 0-9</code></li>
</ul>
<a class="header" href="#ranges" id="ranges"><h4>Ranges</h4></a>
<p>The <code>Range</code> distribution has been heavily adapted, and renamed to <code>Uniform</code>:</p>
<ul>
<li><code>Uniform::new(low, high)</code> remains (half open <code>[low, high)</code>)</li>
<li><code>Uniform::new_inclusive(low, high)</code> has been added, including <code>high</code> in the sample range</li>
<li><code>Uniform::sample_single(low, high, rng)</code> is a faster variant for single usage sampling from <code>[low, high)</code></li>
</ul>
<p><code>Uniform</code> can now be implemented for user-defined types; see the <code>uniform</code> module.</p>
<a class="header" href="#non-uniform-distributions" id="non-uniform-distributions"><h3>Non-uniform distributions</h3></a>
<p>Two distributions have been added:</p>
<ul>
<li>Poisson, modelling the number of events expected from a constant-rate
source within a fixed time interval (e.g. nuclear decay)</li>
<li>Binomial, modelling the outcome of a fixed number of yes-no trials</li>
</ul>
<p>The sampling methods are based on those in &quot;Numerical Recipes in C&quot;.</p>
<a class="header" href="#exponential-and-normal-distributions" id="exponential-and-normal-distributions"><h4>Exponential and Normal distributions</h4></a>
<p>The main <code>Exp</code> and <code>Normal</code> distributions are unchanged, however the
&quot;standard&quot; versions, <code>Exp1</code> and <code>StandardNormal</code> are no longer wrapper types,
but full distributions. Instead of writing <code>let Exp1(x) = rng.gen();</code> you now
write <code>let x = rng.sample(Exp1);</code>.</p>
<a class="header" href="#updating-to-06" id="updating-to-06"><h1>Updating to 0.6</h1></a>
<p>TODO</p>
<a class="header" href="#contributing" id="contributing"><h1>Contributing</h1></a>
<p>Thank you for your interest in contributing to Rand!</p>
<p>The following is a list of notes and tips for when you want to contribute to
Rand with a pull request.</p>
<p>If you want to make major changes, it is usually best to open an issue to
discuss the idea first.</p>
<a class="header" href="#code-style" id="code-style"><h2>Code style</h2></a>
<p>Rand doesn't (yet) use rustfmt. It is best to follow the style of the
surrounding code, and try to keep an 80 character line limit.</p>
<a class="header" href="#documentation" id="documentation"><h1>Documentation</h1></a>
<p>We are very happy to recieve documentation pull-requests.</p>
<p>Documentation is split into two parts: the API documentation (from the code,
usually in <a href="https://github.com/rust-random/rand">rust-random/rand</a>), and this
book (from <a href="https://github.com/rust-random/book">rust-random/book</a>).</p>
<a class="header" href="#style" id="style"><h2>Style</h2></a>
<p>All documentation is in English, but no particular dialect is preferred.</p>
<p>The documentation should be accessible to multiple audiences: both seasoned
Rustaceans and relative newcomers, those with experience in statistical
modelling or cryptography, as well as those new to the subjects. Since it is
often impossible to write appropriate one-size-fits-all documentation, we
prefer concise technical documentation with reference to extended articles
aimed at more specific audiences.</p>
<a class="header" href="#building-and-testing" id="building-and-testing"><h2>Building and testing</h2></a>
<a class="header" href="#api-documentation" id="api-documentation"><h3>API documentation</h3></a>
<p>To build the API documentation locally, run:</p>
<pre><code class="language-sh"># Build doc for all modules:
cargo doc --all --no-deps

# And open it:
xdg-open target/doc/rand/index.html
</code></pre>
<p>On Linux, it is easy to set up automatic rebuilds after any edit:</p>
<pre><code class="language-sh">while inotifywait -r -e close_write src/ rand_core/; do cargo doc; done
</code></pre>
<p>After editing API documentation, we reccomend testing examples and
checking for broken links:</p>
<pre><code class="language-sh">cargo test --doc

cargo install cargo-deadlinks
# It is recommended to remove left-over files from previous compilations
rm -rf /target/doc
cargo doc --all --no-deps
cargo deadlinks --dir target/doc
</code></pre>
<a class="header" href="#the-book" id="the-book"><h3>The book</h3></a>
<p>The book is built using mdbook, which makes building and testing easy:</p>
<pre><code class="language-sh">cargo install mdbook --version &quot;^0.2&quot;

mdbook build --open
mdbook test

# To automatically rebuild after any changes:
mdbook watch
</code></pre>
<p>Note that links in the book are relative and designed to work in the
<a href="https://rust-random.github.io/book/">published book</a>. If you build the book
locally, you might want to set up a symbolic link pointing to your build of the
API documentation:</p>
<pre><code class="language-sh">ln -s ../rand/target/doc rand
</code></pre>
<a class="header" href="#testing" id="testing"><h1>Testing</h1></a>
<p>Rand has a number of unit tests, though these are not comprehensive or perfect
(improvements welcome). We prefer to have tests for all new functionality.</p>
<p>The first line of testing is simply to run <code>cargo test</code> from the appropriate
directory. Since Rand supports <code>no_std</code> (core-only), <code>core+alloc</code> and <code>std</code>
environments, it is important to test all three (depending on which features
are applicable to the code in question):</p>
<pre><code class="language-sh"># Test using std:
cargo test
# Test using only core:
cargo test --tests --no-default-features
# Test using core + alloc (requires nightly):
cargo +nightly test --tests --no-default-features --features=alloc
</code></pre>
<p>It may also be worth testing with other feature flags:</p>
<pre><code class="language-sh">cargo test --all-features
</code></pre>
<p>Note that this only tests the current package (i.e. the main Rand lib when run
from the repo's top level). To test another lib, <code>cd</code> to its directory.</p>
<p>We do not recommend using Cargo's <code>--package</code> option due to its
<a href="https://github.com/rust-lang/cargo/issues/5364">surprising interactions</a>
with <code>--feature</code> options and failure when multiple versions of the same package
are in the build tree. The CI instead uses <code>--manifest-path</code> to select packages;
while developing, using <code>cd</code> is easier.</p>
<a class="header" href="#writing-tests" id="writing-tests"><h2>Writing tests</h2></a>
<p>Tests may be unit tests within a <code>test</code> sub-module, documentation examples,
example applications (<code>examples</code> dir), integration tests (<code>tests</code> dir), or
benchmarks (<code>benches</code> dir).</p>
<p>Note that <em>only</em> unit tests and integration tests are expected to pass in
<code>no_std</code> (core only) and <code>core+alloc</code> configurations. This is a deliberate
choice; example code should only need to target the common case (<code>std</code>).</p>
<a class="header" href="#random-number-generators" id="random-number-generators"><h3>Random Number Generators</h3></a>
<p>Often test code needs some RNG to test with, but does not need any particular
RNG. In this case, we prefer use of <code>::test::rng</code> which is simple, fast to
initialise and deterministic:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut rng = ::test::rng(528); // just pick some number
#}</code></pre></pre>
<p>Various tests concern properties which are <em>probably</em> true, but not definitely.
We prefer that such tests are deterministic to avoid spurious failures.</p>
<a class="header" href="#benchmarks" id="benchmarks"><h1>Benchmarks</h1></a>
<p>Running benchmarks is easy (but requires a nightly compiler):</p>
<pre><code class="language-sh">cargo bench

# In a few cases, nightly features may use different code paths:
cargo bench --features=nightly
</code></pre>
<p>A lot of code in Rand is performance sensitive, most of it is expected to be
used in hot loops in some libraries/applications. If you change code in
<code>rand_core</code>, in PRNG crates, or in the <code>rngs</code> or <code>distributions</code> modules
(especially when an 'obvious cleanup'), make sure the benchmarks do not regress.</p>
<p>Please report before-and-after results for any affected benchmarks. If you are
optimising something previously not benchmarked, please add new benchmarks
first, then add your changes in a separate commit (to make before-and-after
benchmarking easy).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
